// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"fes"
	"sync"
)

// Ensure, that RawRideFetcherMock does implement fes.RawRideFetcher.
// If this is not the case, regenerate this file with moq.
var _ fes.RawRideFetcher = &RawRideFetcherMock{}

// RawRideFetcherMock is a mock implementation of fes.RawRideFetcher.
//
// 	func TestSomethingThatUsesRawRideFetcher(t *testing.T) {
//
// 		// make and configure a mocked fes.RawRideFetcher
// 		mockedRawRideFetcher := &RawRideFetcherMock{
// 			FetchRawRideFunc: func() (fes.RawRide, bool, error) {
// 				panic("mock out the FetchRawRide method")
// 			},
// 		}
//
// 		// use mockedRawRideFetcher in code that requires fes.RawRideFetcher
// 		// and then make assertions.
//
// 	}
type RawRideFetcherMock struct {
	// FetchRawRideFunc mocks the FetchRawRide method.
	FetchRawRideFunc func() (fes.RawRide, bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// FetchRawRide holds details about calls to the FetchRawRide method.
		FetchRawRide []struct {
		}
	}
	lockFetchRawRide sync.RWMutex
}

// FetchRawRide calls FetchRawRideFunc.
func (mock *RawRideFetcherMock) FetchRawRide() (fes.RawRide, bool, error) {
	if mock.FetchRawRideFunc == nil {
		panic("RawRideFetcherMock.FetchRawRideFunc: method is nil but RawRideFetcher.FetchRawRide was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFetchRawRide.Lock()
	mock.calls.FetchRawRide = append(mock.calls.FetchRawRide, callInfo)
	mock.lockFetchRawRide.Unlock()
	return mock.FetchRawRideFunc()
}

// FetchRawRideCalls gets all the calls that were made to FetchRawRide.
// Check the length with:
//     len(mockedRawRideFetcher.FetchRawRideCalls())
func (mock *RawRideFetcherMock) FetchRawRideCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFetchRawRide.RLock()
	calls = mock.calls.FetchRawRide
	mock.lockFetchRawRide.RUnlock()
	return calls
}
